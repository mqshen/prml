在我们能够在实际应用中使用前向后向算法之前，有一件事情必须强调。根据递归关系（13.36），我们注意到在每一步中，新的值$$ \alpha(z_n) $$为前一个值$$ \alpha(z_{n−1}) $$乘以$$ p(z_n| z_{n−1}) $$和$$ p(x_n|z_n) $$。由于这些概率通常远远小于1，因此随着我们沿着链向前推进，$$ \alpha(z_n) $$很快就会指数地趋近于零。对于中等的链长度（例如100左右），$$ \alpha(z_n) $$的计算很快就会超出计算机的计算范围，即使使用双精度浮点数也是如此。    

在独立同分布数据的情形，我们使用取对数的方式，隐式地避开了计算似然函数的这个问题。不幸的是，这种方法在这里没有作用，因为我们对很小的数字的乘积进行求和（事实上我们隐式地对图13.7的晶格图中的所有可能的路径求和）。因此我们使用重新缩放的$$ \alpha(z_n) $$和$$ \beta(z_n) $$来计算，它们的值保持与单位长度在同一个量级上。正如我们将看到的那样，当我们在EM算法中使用这些缩放的量时，对应的缩放因子会消去。    

在式（13.34）中，我们定义了$$ \alpha(z_n) = p(x_1,...,x_n,z_n) $$，表示所有截止到$$ x_n $$的观测以及潜在变量$$ z_n $$的联合概率分布。现在我们定义$$ \alpha $$的一个标准化的版本，形式为    

$$
\hat(z_n) = p(z_n|x_1,...,x_n) = \frac{\alpha(z_n)}{p(x_1,...,x_n) \tag{13.55}
$$    

我们预计这个量在数值计算上可以表现良好，因为对任意$$ n $$值，它都是$$ K $$个变量上的一个概率分布。为了将缩放的alpha变量与原始的alpha变量关联起来，我们引入缩放因子，它由观测变量上的条件概率分布定义，即    

$$
c_n = p(x_n|x_1,...,x_{n-1}) \tag{13.56}
$$    

根据乘积规则，我们有    

$$
p(x_1,...,x_n) = \prod\limits_{m=1}^n c_m \tag{13.57}
$$    

因此    

$$
\alpha(z_n) = p(z_n|x_1,...,x_n)p(x_1,...,x_n) = \left(\prod\limits_{m=1}^nc_m\right)\hat{\alpha}(z_n) \tag{13.58}
$$    

然后我们可以将$$ \alpha $$的递归方程（13.36）转化为$$ \hat{\alpha} $$的递归方程，形式为    

$$
c_n\hat{\alpha}(z_n) = p(x_n|z_n)\sum\limits_{z_{n-1}}\hat{\alpha}(z_{n-1})p(z_n|z_{n-1}) \tag{13.59}
$$    

注意，在用于计算$$ \hat{\alpha}(z_n) $$的前向信息传播阶段的每一步，我们必须计算和存储$$ c_n $$，这很容易做到，因为它是将式（13.59）的右手边标准化得到$$ \hat{\alpha}(z_n) $$的标准化系数。     

类似的，我们可以使用下式

$$
\beta(z_n) = \left(\prod\limits_{m=n+1}^Nc_m\right)\hat{\beta}(z_n) \tag{13.60}
$$    

定义重新缩放的变量$$ \beta(z_n) $$。它的值再次保持在机器的精度范围内，因为根据式（13.35），$$ \hat{\beta}(z_n) $$仅仅是两个条件概率分布的比值    

$$
\hat{\beta}(z_n) = \frac{p(x_{n+1},...,x_N|z_n)}{p(x_{n+1},...,x_N|x_1,...,x_n)} \tag{13.61}
$$    

这样，根据$$ \beta $$的递归结果（13.38）可以得到下面的对重新标准的变量的递归方程    

$$
c_{n+1}\hat{\beta}(z_n) = \sum\limits_{z_{n+1}}\hat{\beta}(z_{n+1})p(x_{n+1}|z_{n+1})p(z_{n+1}|z_n) \tag{13.62}
$$    

在应用这个递归关系时，我们使用之前在$$ \alpha $$阶段计算的缩放因子$$ c_n $$。    

根据式（13.57），我们看到似然函数可以使用下式求出    

$$
p(X) = \prod\limits_{n=1}^Nc_n \tag{13.63}
$$    

类似地，使用（13.33）和（13.43）以及（13.63），我们看到所求的边缘概率为    

$$
\begin{eqnarray}
\gamma(z_n) &=& \hat{\alpha}(z_n)\hat{\beta}(z_n) \tag{13.64} \\
\xi(z_{n-1},z_n) &=& c_n^{-1}\hat{\alpha}(z_{n-1})p(x_n|z_n)p(z_n|z_{n-1})\hat{\beta}(z_n) \tag{13.65}
\end{eqnarray}
$$    

最后，我们注意到前向后向算法有另一种公式（Jordan，2007），其中后向传递由基于$$ \gamma(z) = \hat{\alpha}(z_n)\hat{\beta}(z_n) $$的递归定义，而不是使用$$ \hat{\beta}(z_n) $$。这个$$ \alpha − \gamma $$递归要求前向传递过程首先完成，从而在后向传递过程中能得到所有的$$ \hat{\alpha}(z_n) $$，而$$ \alpha − \beta $$算法的前向和向后传播可以独立地进行。虽然这两个算法的计算代价是可比的，但是在隐马尔可夫模型的情形下，$$ \alpha − \beta
$$版本是最经常遇到的，而对于线性动态系统，$$ \alpha − \gamma $$形式类似的递归规程更常见。
